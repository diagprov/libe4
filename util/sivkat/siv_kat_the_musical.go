package main

import (
	"bytes"
	"crypto/rand"
	"fmt"
	e4crypto "github.com/teserakt-io/e4go/crypto"
	"io"
	"os"
)

const SIV_KATS = 1024
const prologue = `/* This file is autogenerated. Please do not modify it directly. */

#ifndef E4_SIV_KAT
#define E4_SIV_KAT

typedef struct _e4_aessiv_kat {
    const uint8_t ciphertext[116];
    const uint8_t plaintext[100];
    const uint8_t ad[32];
	const uint8_t key[32];
} e4_aessiv_kat;


`

const epilogue = `

#endif /* E4_SIV_KAT */

`

func printBinaryAsCArray(w io.Writer, lovelyslice []byte) {

	slicelen := len(lovelyslice)
	fmt.Fprintf(w, "{")
	for i, b := range lovelyslice {
		fmt.Fprintf(w, "0x%02x", b)
		if i != slicelen-1 {
			fmt.Fprintf(w, ", ")
		}
	}
	fmt.Fprintf(w, "}")
}

func main() {
	header, _ := os.OpenFile("siv_kat.h", os.O_RDWR|os.O_CREATE, 0644)

	fmt.Fprintf(header, prologue)

	fmt.Fprintf(header, "#define SIV_KAT_NUM %d\n\n", SIV_KATS)
	fmt.Fprintf(header, "e4_aessiv_kat siv_kats[%d] = {\n", SIV_KATS)

	for i := 0; i < SIV_KATS; i++ {

		pt := make([]byte, 100)
		ad := make([]byte, 32)
		key := make([]byte, 32)
		rand.Read(pt)
		rand.Read(ad)
		rand.Read(key)

		ct, err := e4crypto.Encrypt(key, ad, pt)
		if err != nil {
			panic("encryption failed")
		}

		recovered, err := e4crypto.Decrypt(key, ad, ct)
		if err != nil {
			panic("decryption failed")
		}
		if !bytes.Equal(recovered, pt) {
			panic("corrupted data")
		}

		fmt.Fprintf(header, "{\n")

		fmt.Fprintf(header, ".ciphertext = ")
		printBinaryAsCArray(header, ct[:])
		fmt.Fprintf(header, ",\n")
		fmt.Fprintf(header, ".plaintext = ")
		printBinaryAsCArray(header, pt[:])
		fmt.Fprintf(header, ",\n")
		fmt.Fprintf(header, ".ad = ")
		printBinaryAsCArray(header, ad[:])
		fmt.Fprintf(header, ",\n")
		fmt.Fprintf(header, ".key = ")
		printBinaryAsCArray(header, key[:])
		fmt.Fprintf(header, "}\n")

		if i != SIV_KATS-1 {
			fmt.Fprint(header, ",")
		}

	}

	fmt.Fprintf(header, "};\n")

	fmt.Fprintf(header, epilogue)

	header.Close()
}
